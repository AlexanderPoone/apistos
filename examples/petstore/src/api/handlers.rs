use crate::api::error::ErrorResponse;
use crate::api::models::{Category, Pet, Status, Tag};
use actix_web::web::Json;
use actix_web::Error;
use netwopenapi::actix::ResponderWrapper;
use netwopenapi::path_item_definition::PathItemDefinition;
use netwopenapi::ApiComponent;
use netwopenapi_gen::api_operation;
use std::collections::BTreeMap;
use std::sync::Arc;
use utoipa::openapi::path::Operation;
use utoipa::openapi::{Components, ComponentsBuilder, PathItem};

// /// Should be generated by macro
// #[allow(non_camel_case_types)]
// #[doc(hidden)]
// pub struct __openapi_update_pet;
//
// impl PathItemDefinition for __openapi_update_pet {
//   fn is_visible() -> bool {
//     true
//   }
//
//   fn operation() -> Operation {
//     let mut operation_builder = utoipa::openapi::path::OperationBuilder::new();
//     let request_body = <Json<Pet>>::request_body();
//
//     operation_builder = operation_builder.request_body(request_body);
//     operation_builder.build()
//     //
//     // .request_body(
//     //   Some(
//     //     utoipa::openapi::request_body::RequestBodyBuilder::new()
//     //       .content(
//     //         "application/json",
//     //         utoipa::openapi::content::ContentBuilder::new()
//     //           .schema(utoipa::openapi::Ref::from_schema_name("Pet"))
//     //           .build(),
//     //       )
//     //       .required(Some(utoipa::openapi::Required::True))
//     //       .build(),
//     //   ),
//     // )
//     // .responses(
//     //   utoipa::openapi::ResponsesBuilder::new()
//     //     .response(
//     //       "201",
//     //       utoipa::openapi::ResponseBuilder::new()
//     //         .description("Todo created successfully")
//     //         .content(
//     //           "application/json",
//     //           utoipa::openapi::ContentBuilder::new()
//     //             .schema(utoipa::openapi::Ref::from_schema_name("Pet"))
//     //             .build(),
//     //         )
//     //         .build(),
//     //     )
//     //     .response(
//     //       "409",
//     //       utoipa::openapi::ResponseBuilder::new()
//     //         .description("Todo with id already exists")
//     //         .content(
//     //           "application/json",
//     //           utoipa::openapi::ContentBuilder::new()
//     //             .schema(
//     //               utoipa::openapi::Ref::from_schema_name("ErrorResponse"),
//     //             )
//     //             .build(),
//     //         )
//     //         .build(),
//     //     )
//     //     .build(),
//     // )
//     // .operation_id(Some("create_todo"))
//     // .summary(Some("Create new Todo to shared in-memory storage."))
//     // .description(
//     //   Some(
//     //     "Create new Todo to shared in-memory storage.\n\nPost a new `Todo` in request body as json to store it. Api will return\ncreated `Todo` on success or `ErrorResponse::Conflict` if todo with same id already exists.\n\nOne could call the api with.\n```text\ncurl localhost:8080/todo -d '{\"id\": 1, \"value\": \"Buy movie ticket\", \"checked\": false}'\n```",
//     //   ),
//     // )
//     // .tag(
//     //   *[Some(""), Some("crate")]
//     //     .iter()
//     //     .flatten()
//     //     .find(|t| !t.is_empty())
//     //     .unwrap(),
//     // ).build()
//   }
//
//   fn components() -> BTreeMap<String, Components> {
//     let mut components = BTreeMap::new();
//     components.insert("Pet".to_owned(), ComponentsBuilder::new().schema_from::<Pet>().build());
//     components.insert(
//       "Category".to_owned(),
//       ComponentsBuilder::new().schema_from::<Category>().build(),
//     );
//     components.insert(
//       "Status".to_owned(),
//       ComponentsBuilder::new().schema_from::<Status>().build(),
//     );
//     components.insert("Tag".to_owned(), ComponentsBuilder::new().schema_from::<Tag>().build());
//     components.insert(
//       "ErrorResponse".to_owned(),
//       ComponentsBuilder::new().schema_from::<ErrorResponse>().build(),
//     );
//     components
//   }
// }
//
// // summary: Update an existing pet
// // description: Update an existing pet by Id
// // operationId: updatePet
// pub(crate) fn update_pet(
//   // Update an existent pet in the store
//   body: Json<Pet>,
// ) -> impl std::future::Future<Output = Result<Json<Pet>, ErrorResponse>> + PathItemDefinition {
//   ResponderWrapper {
//     inner: (move || async move { Ok(body) })(),
//     path_item: __openapi_update_pet,
//   }
// }

#[api_operation]
pub(crate) async fn update_pet(
  // Create a new pet in the store
  body: Json<Pet>,
) -> Result<Json<Pet>, Error> {
  Ok(body)
}

// summary Add a new pet to the store
// description Add a new pet to the store
// operationId addPet
pub(crate) async fn add_pet(
  // Create a new pet in the store
  body: Json<Pet>,
) -> Result<Json<Pet>, Error> {
  Ok(body)
}
