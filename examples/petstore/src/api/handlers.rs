use std::collections::BTreeMap;
use crate::api::models::{Category, Pet, Status, Tag};
use actix_web::web::Json;
use actix_web::Error;
use utoipa::openapi::{Components, ComponentsBuilder, PathItem};
use netwopenapi::actix::ResponderWrapper;
use netwopenapi::path_item_definition::PathItemDefinition;
use crate::api::error::ErrorResponse;

/// Should be generated by macro
#[allow(non_camel_case_types)]
#[doc(hidden)]
pub struct __openapi_update_pet;
impl PathItemDefinition for __openapi_update_pet {
  fn is_visible() -> bool {
    true
  }

  fn path_item(default_tag: Option<&str>) -> PathItem {
    PathItem::new(
      utoipa::openapi::PathItemType::Post,
      utoipa::openapi::path::OperationBuilder::new()
        .request_body(
          Some(
            utoipa::openapi::request_body::RequestBodyBuilder::new()
              .content(
                "application/json",
                utoipa::openapi::content::ContentBuilder::new()
                  .schema(utoipa::openapi::Ref::from_schema_name("Pet"))
                  .build(),
              )
              .required(Some(utoipa::openapi::Required::True))
              .build(),
          ),
        )
        .responses(
          utoipa::openapi::ResponsesBuilder::new()
            .response(
              "201",
              utoipa::openapi::ResponseBuilder::new()
                .description("Todo created successfully")
                .content(
                  "application/json",
                  utoipa::openapi::ContentBuilder::new()
                    .schema(utoipa::openapi::Ref::from_schema_name("Pet"))
                    .build(),
                )
                .build(),
            )
            .response(
              "409",
              utoipa::openapi::ResponseBuilder::new()
                .description("Todo with id already exists")
                .content(
                  "application/json",
                  utoipa::openapi::ContentBuilder::new()
                    .schema(
                      utoipa::openapi::Ref::from_schema_name("ErrorResponse"),
                    )
                    .build(),
                )
                .build(),
            )
            .build(),
        )
        .operation_id(Some("create_todo"))
        .summary(Some("Create new Todo to shared in-memory storage."))
        .description(
          Some(
            "Create new Todo to shared in-memory storage.\n\nPost a new `Todo` in request body as json to store it. Api will return\ncreated `Todo` on success or `ErrorResponse::Conflict` if todo with same id already exists.\n\nOne could call the api with.\n```text\ncurl localhost:8080/todo -d '{\"id\": 1, \"value\": \"Buy movie ticket\", \"checked\": false}'\n```",
          ),
        )
        .tag(
          *[Some(""), default_tag, Some("crate")]
            .iter()
            .flatten()
            .find(|t| !t.is_empty())
            .unwrap(),
        ),
    )
  }

  fn components() -> BTreeMap<String, Components> {
    let mut components = BTreeMap::new();
    components.insert("Pet".to_owned(), ComponentsBuilder::new().schema_from::<Pet>().build());
    components.insert("Category".to_owned(), ComponentsBuilder::new().schema_from::<Category>().build());
    components.insert("Status".to_owned(), ComponentsBuilder::new().schema_from::<Status>().build());
    components.insert("Tag".to_owned(), ComponentsBuilder::new().schema_from::<Tag>().build());
    components.insert("ErrorResponse".to_owned(), ComponentsBuilder::new().schema_from::<ErrorResponse>().build());
    components
  }
}

// summary: Update an existing pet
// description: Update an existing pet by Id
// operationId: updatePet
pub(crate) fn update_pet(
  // Update an existent pet in the store
  body: Json<Pet>,
) -> impl std::future::Future<
  Output = Result<Json<Pet>, ErrorResponse>,
> + PathItemDefinition {
  ResponderWrapper {
    inner: (move || async move { Ok(body) })(),
    path_item: __openapi_update_pet,
  }
}

// summary Add a new pet to the store
// description Add a new pet to the store
// operationId addPet
pub(crate) async fn add_pet(
  // Create a new pet in the store
  body: Json<Pet>,
) -> Result<Json<Pet>, Error> {
  Ok(body)
}
